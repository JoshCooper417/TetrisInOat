# 1 "tetris.oat"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "tetris.oat"

# 1 "lib/console.oat" 1





unit con_init() extern


unit con_cleanup() extern


unit con_print(string str) extern


unit con_printch(int ch) extern


unit con_move(int x, int y) extern


unit con_attrset(int attr) extern


int con_attrget() extern


unit con_clrtoeol() extern


unit con_clear() extern


unit con_refresh() extern


int con_getch() extern


int con_color(int c) extern


int con_bold(int c) extern


int con_width() extern


int con_height() extern


int con_sleep(int amt) extern

int con_halfdelay(int x) extern

# 2 "tetris.oat" 2

# 1 "lib/list.oat" 1





bool equals(Object? o1, Object? o2) {
  return o1 == o2;
}

class ListItem <: Object {
  Object? obj;
  ListItem? prev;
  ListItem? next;

  new (Object? o)() {
    this.obj = o;
    this.prev = null;
    this.next = null;
  }
};

class List <: Object {
  ListItem? head;

  new ()() {
    this.head = null;
  }

  bool is_empty() {
    return equals(this.head, null);
  }

  
  unit insert(Object o) {
    ListItem new_item = new ListItem(o);
    new_item.next = this.head;
    if? (ListItem old_head = this.head)
      old_head.prev = new_item;
    this.head = new_item;
    return;
  }

  
  unit remove(ListItem item) {
    if (equals(item, this.head)) {
      
      this.head = item.next;
      if? (ListItem next = item.next) 
        next.prev = null;
    } else {
      
      if? (ListItem prev = item.prev) {
        prev.next = item.next;
        if? (ListItem next = item.next)
           next.prev = prev;
      } else fail ( "invalid list" );
    }
    return;    
  }

};





# 3 "tetris.oat" 2

# 1 "lib/math.oat" 1



int oat_div (int a, int b) extern
int oat_mod (int a, int b) extern
 
# 4 "tetris.oat" 2
class Shape <: Object {
  int[][] points;
  int [] center;
  new(int type)()
   this.points = {{0,0},{0,0},{0,0},{0,0}};
  this.center = {0,0};
  {
    if(type == 0){
      



      this.points[0][0]= 0;
      this.points[0][1]= 0;
      this.points[1][0]= 0;
      this.points[1][1]= 1;
      this.points[2][0]= 0;
      this.points[2][1]= 2;
      this.points[3][0]= 0;
      this.points[3][1]= 3;

      this.center[0] = 0;
      this.center[1] = 3;
    }
    else if (type == 1){
      

      this.points[0][0]= 0;
      this.points[0][1]= 0;
      this.points[1][0]= 1;
      this.points[1][1]= 0;
      this.points[2][0]= 0;
      this.points[2][1]= 1;
      this.points[3][0]= 1;
      this.points[3][1]= 1;

      this.center[0] = 0;
      this.center[1] = 1;
    }
    else if (type == 2){
      

      this.points[0][0]= 1;
      this.points[0][1]= 0;
      this.points[1][0]= 0;
      this.points[1][1]= 1;
      this.points[2][0]= 1;
      this.points[2][1]= 1;
      this.points[3][0]= 2;
      this.points[3][1]= 1;
  
      this.center[0] = 0;
      this.center[1] = 1;
    }
    else if (type == 3){
      

      this.points[0][0]= 0;
      this.points[0][1]= 0;
      this.points[1][0]= 1;
      this.points[1][1]= 0;
      this.points[2][0]= 1;
      this.points[2][1]= 1;
      this.points[3][0]= 2;
      this.points[3][1]= 1;
     
      this.center[0] = 1;
      this.center[1] = 1;
    }
    else if (type == 4){
      

      this.points[0][0]= 1;
      this.points[0][1]= 0;
      this.points[1][0]= 2;
      this.points[1][1]= 0;
      this.points[2][0]= 0;
      this.points[2][1]= 1;
      this.points[3][0]= 1;
      this.points[3][1]= 1;
    
      this.center[0] = 1;
      this.center[1] = 1;
    }
    else if (type == 5){
      


      this.points[0][0]= 0;
      this.points[0][1]= 0;
      this.points[1][0]= 1;
      this.points[1][1]= 0;
      this.points[2][0]= 1;
      this.points[2][1]= 1;
      this.points[3][0]= 1;
      this.points[3][1]= 2;
     
      this.center[0] = 1;
      this.center[1] = 2;
    }
    else if (type == 6){
      


      this.points[0][0]= 0;
      this.points[0][1]= 0;
      this.points[1][0]= 1;
      this.points[1][1]= 0;
      this.points[2][0]= 0;
      this.points[2][1]= 1;
      this.points[3][0]= 0;
      this.points[3][1]= 2;
   
      this.center[0] = 0;
      this.center[1] = 2;
    }
    }
    unit move_down(){
      bool can_move = true;
      for(int i = 0; i<4; i=i+1;){
	if (this.points[i][1] > 48)
	  can_move = false;
      }

      if (can_move){
	this.center[1] = this.center[1] + 1;
       for(int i = 0; i<4; i=i+1;){
	this.points[i][1] = this.points[i][1] + 1;
        }
      }
      return;
    }
    unit move_left(){
      bool can_move = true;
      for(int i = 0; i<4; i=i+1;){
	if(this.points[i][0] < 1){
	  can_move = false;
	}
      }
      if (can_move){
	this.center[0] = this.center[0] - 1;
       for(int i = 0; i<4; i=i+1;){
	 this.points[i][0] = this.points[i][0] - 1;
        }
      }

      return;
    }
    unit move_right(){
      bool can_move = true;
      for(int i = 0; i<4; i=i+1;){
	if(this.points[i][0] > 8){
	  can_move = false;
	}
      }

      if (can_move){
       this.center[0] = this.center[0] + 1;
       for(int i = 0; i<4; i=i+1;){
	 this.points[i][0] = this.points[i][0] + 1;
        }
      }
      return;
    }

      unit rotate_right()
      {
	 int [][] oldpoints = {{0,0},{0,0},{0,0},{0,0}};
	 bool can_move = true;
	  for(int i = 0; i < 4; i = i + 1;)
	    {
	      oldpoints[i][0] = this.points[i][0];
	      oldpoints[i][1] = this.points[i][1];
	   }

      	for (int i = 0; i < 4; i = i + 1;)
	  {
	    int temp = 0;

	    
	    this.points[i][0] =  this.points[i][0] - this.center[0];
	    this.points[i][1] =  this.points[i][1] - this.center[1];

	     

	    temp =  -1*this.points[i][1];
	    this.points[i][1] =  this.points[i][0];
	    this.points[i][0] = temp;
	    
	   
            this.points[i][0] =  this.points[i][0] + this.center[0];
	    this.points[i][1] =  this.points[i][1] + this.center[1];

	    if ((this.points[i][1] < 0) | 
		(this.points[i][1] > 49) | 
		(this.points[i][0] < 0) | 
		(this.points[i][0] > 9))
	      can_move = false;
	  } 

	if (can_move == false){
	  for(int i = 0; i < 4; i = i + 1;)
	    {
	      this.points[i][0] = oldpoints[i][0];
	      this.points[i][1] = oldpoints[i][1];
	   }
	}

	return;
      }

      unit rotate_left()
      {
	 int [][] oldpoints = {{0,0},{0,0},{0,0},{0,0}};
	 bool can_move = true;
	  for(int i = 0; i < 4; i = i + 1;)
	    {
	      oldpoints[i][0] = this.points[i][0];
	      oldpoints[i][1] = this.points[i][1];
	   }

      	for (int i = 0; i < 4; i = i + 1;)
	  {
	    int temp = 0;

	    
	    this.points[i][0] =  this.points[i][0] - this.center[0];
	    this.points[i][1] =  this.points[i][1] - this.center[1];

	     

	    temp =  this.points[i][1];
	    this.points[i][1] =  -1*this.points[i][0];
	    this.points[i][0] = temp;

	   
            this.points[i][0] =  this.points[i][0] + this.center[0];
	    this.points[i][1] =  this.points[i][1] + this.center[1];

	    if ((this.points[i][1] < 0) | 
		(this.points[i][1] > 49) | 
		(this.points[i][0] < 0) | 
		(this.points[i][0] > 9))
	      can_move = false;
	  } 

	if (can_move == false){
	  for(int i = 0; i < 4; i = i + 1;)
	    {
	      this.points[i][0] = oldpoints[i][0];
	      this.points[i][1] = oldpoints[i][1];
	   }
	}

	return;
      }

};


class State <: Object {
  Shape shape;
  int type;
  int[][] grid;
  new ()() 
    this.shape = new Shape(0);
  this.grid = new int[][10](fun i -> new int[50](fun j -> 0));
  {
  }

  unit make_new_shape(){
    this.type = this.type + 1;
    if(this.type == 7){
      this.type = 0;
    }
    this.shape = new Shape(this.type);
    return;
  }

  unit init() {
    return;
  }

  bool update(int k) {
     bool collided = false;
     bool returnVal = false;
    int[][] original_points = {{0,0},{0,0},{0,0},{0,0}};
    for(int i = 0; i < 4; i = i + 1;)
	    {
	      original_points[i][0] = this.shape.points[i][0];
	      original_points[i][1] = this.shape.points[i][1];
	   }
    for(int i = 0; i<4; i=i+1;){
	int old_shapex = original_points[i][0];
	int old_shapey = original_points[i][1];
      	this.grid[old_shapex][old_shapey] = 0;
     }
    if (k == 106) 
       this.shape.move_left();
    if (k == 108)
       this.shape.move_right();
    if (k == 105)
      this.shape.rotate_right();
    if (k == 104)
      this.shape.rotate_left();
    this.shape.move_down();
    for(int i = 0; i<4; i=i+1;){
      int shapex = this.shape.points[i][0];
      int shapey = this.shape.points[i][1];

      if((this.grid[shapex][shapey]==1) | (shapey == 49)){
	  collided = true;
	}
    }
    
    if(collided){
      this.make_new_shape();
     for(int i = 0; i<4; i=i+1;){
	int old_shapex = original_points[i][0];
	int old_shapey = original_points[i][1];
      	this.grid[old_shapex][old_shapey] = 1;
     }
   for(int j = 0; j< 50;j=j+1;){
      bool complete = true;
      for(int i = 0; i<10; i=i+1;){
	if(this.grid[i][j]==0)
	  complete = false;
      }
      if(complete){
	for(int m = j; m > 0; m = m -1;){
	  for(int l = 0; l<10;l=l+1;){
	    this.grid[l][m] = this.grid[l][m-1];
	  }
	}
	
	for(int l = 0; l<10;l=l+1;){
	    this.grid[l][0] =0;
	  }
      }
     }
   
   	for(int l = 0; l<10;l=l+1;){
	  if(this.grid[l][0] != 0)
	    returnVal = true;
	  }
    }

    
    else{
      for(int i = 0; i<4; i=i+1;){
	int shapex = this.shape.points[i][0];
	int shapey = this.shape.points[i][1];
	this.grid[shapex][shapey] = 1;
     }
     }

     return returnVal;
  }
  unit display() {
    int color = 0;
    con_clear();
    color = con_color(143);
    draw(this.grid);
    con_refresh();
    return;
  }
};

unit instructions() {
  int k = 0;
  con_move(0,0);
  con_print("
    TETRIS. \n
      j - Move left \n
      l - Move right \n
      i - Rotate right \n
      h - Rotate left \n
      [Press any key to begin]\n");
  k = con_getch();
  return;
}


unit draw(int[][] grid){
  
  for(int i = 0; i < 10; i=i+1;){
    for(int j = 0; j < 50; j=j+1;){
      con_move(2*i,j);
      if(grid[i][j]==1){
	con_print("[]");
      }
    }
  }
  return;
}



int program(int argc, string[] argv) {
  int minx = 80;
  int miny = 25;
  print_string("HERE\n");
   con_init();
  instructions();
  if ((con_width() >= minx) & (con_height() >= miny) ) {
    State state = new State(); 
    bool lost = false;
    int k = 0;
    int something = 0;
       state.init();
    something = con_halfdelay(1);  
    while ((k != 27) & (!lost)) {
      state.display();
      k = con_getch();
     lost = state.update(k);
    }
    con_cleanup();
  } else {
    con_cleanup();
    print_string("Minimum size of the console is 80x25!\n");
  }
  print_string("HERE\n");
  return 0;
}
